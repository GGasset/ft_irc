diff --git a/Authentication/User.cpp b/Authentication/User.cpp
index a745990..698c55e 100644
--- a/Authentication/User.cpp
+++ b/Authentication/User.cpp
@@ -33,6 +33,6 @@ void	User::setNick(std::string nick) {
 	this->nick = nick;
 }
 
-std::vector<size_t>	User::get_joined_channel(size_t id) {
-	return (joined_channels_ids[id]);
+std::vector<size_t>	User::get_joined_channel() {
+	return (joined_channels_ids);
 }
\ No newline at end of file
diff --git a/Authentication/User.hpp b/Authentication/User.hpp
index de38eb5..dc38fb5 100644
--- a/Authentication/User.hpp
+++ b/Authentication/User.hpp
@@ -12,20 +12,20 @@ private:
 	ssize_t id = -1;
 	bool is_channel_operator = false;
 	std::string nick = "";
-	std::string realname;
-	std::string username;
 	std::vector<size_t> joined_channels_ids;
 
 	// current state of the received msg, may not be complete
 	// Is not saved to disk
 	std::string current_message;
-	std::string passw;
 
 public:
 	// Called when this user sends a message
 	// This function is part of the socket function collection
 	std::vector<std::string> msg_sent(void *what_he_wants, size_t msg_len);
 	std::string getNick(void) const;
-	std::vector<size_t>	get_joined_channel(size_t id);
+<<<<<<< HEAD
+	std::vector<size_t>	get_joined_channel();
+=======
+>>>>>>> parent of bb00973 (Cipote absoluto con usuarios, canales y puertos.)
 	void	setNick(std::string nick);
 };
diff --git a/Messaging/Message.cpp b/Messaging/Message.cpp
index 2399915..92ab514 100644
--- a/Messaging/Message.cpp
+++ b/Messaging/Message.cpp
@@ -3,10 +3,10 @@
 /*                                                        :::      ::::::::   */
 /*   Message.cpp                                        :+:      :+:    :+:   */
 /*                                                    +:+ +:+         +:+     */
-/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
+/*   By: alvmoral <alvmoral@student.42madrid.com    +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/11/03 19:24:29 by alvmoral          #+#    #+#             */
-/*   Updated: 2025/11/05 18:19:18 by alvaro           ###   ########.fr       */
+/*   Updated: 2025/11/11 12:08:26 by alvmoral         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
@@ -162,7 +162,7 @@ msgTokens	msgTokenizer(std::string msg)
 	return (ret);
 }
 
-MessageOut fnHandlers::operator()(COMMAND cmd, MessageIn msg)
+MessageOut fnHandlers::operator()(COMMAND cmd, MessageIn msg, Server& server)
 {
-	return fun[cmd](msg);
+	return fun[cmd](cmd, msg, server);
 }
diff --git a/Messaging/Message.hpp b/Messaging/Message.hpp
index dd27d1e..093b156 100644
--- a/Messaging/Message.hpp
+++ b/Messaging/Message.hpp
@@ -60,6 +60,21 @@ enum COMMAND {
 	COMMAND0
 };
 
+typedef struct  MessageIn
+{
+	msgTokens	tokens;
+	COMMAND		cmd;
+}   MessageIn;
+
+// Please, make message a POD type 游땻游뱇
+typedef struct MessageOut
+{
+	std::vector<size_t>	id; //Esto sirve para tanto chanels como usuarios.
+	bool	to_user; //Esto indica si es para un usuario o para un canal.
+    char    msg[512];
+    void    fillMsgOut(User u, std::string servername, std::string cmd, std::string params);
+}   MessageOut;
+
 class fnHandlers
 {
 	MessageOut (*fun[COMMAND0])(size_t, MessageIn, Server&);
@@ -69,15 +84,9 @@ class fnHandlers
 		// fnHandlers(const fnHandlers &fn);
 		// fnHandlers	&operator=(const fnHandlers &fn);
 		~fnHandlers();
-		MessageOut	operator()(COMMAND cmd, MessageIn msg);
+		MessageOut	operator()(COMMAND cmd, MessageIn msg, Server& server);
 };
 
-typedef struct  MessageIn
-{
-	msgTokens	tokens;
-	COMMAND		cmd;
-}   MessageIn;
-
 enum ParseStatus {
     VALID_MSG,
 	PERR_MSG_LENGTH,
@@ -101,16 +110,6 @@ enum ParseStatus {
 
 extern const std::string g_parseErrors[PERR_NONE];
 
-
-// Please, make message a POD type 游땻游뱇
-typedef struct MessageOut
-{
-	std::vector<size_t>	id; //Esto sirve para tanto chanels como usuarios.
-	bool	to_user; //Esto indica si es para un usuario o para un canal.
-    char    msg[512];
-    void    fillMsgOut(User u, std::string servername, std::string cmd, std::string params);
-}   MessageOut;
-
 msgs getMsgs(std::string packet);
 std::string getSPACE(std::string &packet, size_t &beginSpace);
 std::string getTRAIL(std::string &packet, size_t &beginWord);
diff --git a/Messaging/Message_test.cpp b/Messaging/Message_test.cpp
index c1df8af..721460c 100644
--- a/Messaging/Message_test.cpp
+++ b/Messaging/Message_test.cpp
@@ -393,7 +393,38 @@ int main(void)
 		{PREFIX, ":A[]\\`^{}_-"}, {SPACE, " "}, {WORD, "PRIVMSG"}, {SPACE, " "},
 		{PARAM, "#canal"}, {SPACE, " "}, {TRAIL, "chars v치lidos"}, {CRLF, "\r\n"}
 	};
-	test_validity(idx++, packet, testT, VALID_MSG, PRIVMSG);
+	test_validity(idx++, packet, testT, PERR_PREFIX_INVALID_SERVERNAME, COMMAND0);
 	
 	/* Test 31 */
+	packet = ":A[]!\\^@{}_- PRIVMSG #canal :chars v치lidos\r\n";
+	testT = {
+		{PREFIX, ":A[]!\\^@{}_-"}, {SPACE, " "}, {WORD, "PRIVMSG"}, {SPACE, " "},
+		{PARAM, "#canal"}, {SPACE, " "}, {TRAIL, "chars v치lidos"}, {CRLF, "\r\n"}
+	};
+	// test_validity(idx++, packet, testT, VALID_MSG, PRIVMSG);
+
+	/* Test 32 Prefijo doble @addtogroup*/
+	packet = ":Nick!user@host@ PRIVMSG #canal :doble arroba\r\n";
+	testT = {
+		{PREFIX, ":Nick!user@host@"}, {SPACE, " "}, {WORD, "PRIVMSG"}, {SPACE, " "},
+		{PARAM, "#canal"}, {SPACE, " "}, {TRAIL, "doble arroba"}, {CRLF, "\r\n"}
+	};
+	test_validity(32, packet, testT, PERR_PREFIX_INVALID_HOST, COMMAND0);
+
+	/* Test 33 -- Esta la entiende como nick invalido, pero para mi es comando invalido.*/
+	packet = ":Ni ck!user@host PRIVMSG #canal :nick inv치lido\r\n";
+	testT = {
+		{PREFIX, ":Ni"}, {SPACE, " "}, {WORD, "ck!user@host"}, {SPACE, " "},
+		{PARAM, "PRIVMSG"}, {SPACE, " "}, {PARAM, "#canal"}, {SPACE, " "},
+		{TRAIL, "nick inv치lido"}, {CRLF, "\r\n"}
+	};
+	test_validity(33, packet, testT, PERR_INVALID_COMMAND, COMMAND0);
+
+	/* Test 34 */
+	packet = "PRIVMSG #canal :hola:adi칩s\r\n";
+	testT = {
+		{WORD, "PRIVMSG"}, {SPACE, " "}, {PARAM, "#canal"}, {SPACE, " "},
+		{TRAIL, ":hola:adi칩s"}, {CRLF, "\r\n"}
+	};
+	// test_validity(34, packet, testT, )
 }
\ No newline at end of file
diff --git a/Messaging/fnHandlers.cpp b/Messaging/fnHandlers.cpp
index 866b7ba..a27449c 100644
--- a/Messaging/fnHandlers.cpp
+++ b/Messaging/fnHandlers.cpp
@@ -46,10 +46,9 @@ MessageOut handleNick(size_t clientId, MessageIn in, Server &server) {
     clients[clientId].setNick(nickname.str);
     std::string servername = "irc.local"; // Deberia ser el del servidor, extraido del archivo de configuracion.
     out.fillMsgOut(clients[clientId], servername, "NICK", nickname.str);
-    
-    out.id = clients[clientId].get_joined_channel();
+    // out.id = Channels(client[ClientId]);
     complete_registry(clients[clientId]);
-    return (out);
+    return (out); //Se supone que el out ha de irse mandarse por el socket.
 }
 
 MessageOut  handleUser(size_t clientId, MessageIn in, Server &server) {
diff --git a/Socket/Server.hpp b/Socket/Server.hpp
index aeed034..ea22664 100644
--- a/Socket/Server.hpp
+++ b/Socket/Server.hpp
@@ -1,3 +1,6 @@
+#ifndef SERVER_H
+# define SERVER_H
+
 #include <cstddef>
 #include <string>
 #include <tuple>
@@ -41,7 +44,6 @@ public:
 	User &get_user_by_nick(std::string nick);
 	std::vector<User&> get_channel_users(const Channel channel);
 	Channel &get_by_channel_name(std::string name);
-	Channel &get_by_channel_(std::string name);
 
 	void stop();
 
@@ -57,3 +59,5 @@ public:
 	// Returns true on errors
 	int loop(size_t PORT);
 };
+
+#endif
\ No newline at end of file
diff --git a/bircd/Makefile b/bircd/Makefile
new file mode 100644
index 0000000..3ce5988
--- /dev/null
+++ b/bircd/Makefile
@@ -0,0 +1,28 @@
+
+SRCS =	main.c init_env.c clean_fd.c get_opt.c x.c main_loop.c \
+	init_fd.c do_select.c check_fd.c \
+	srv_create.c srv_accept.c \
+	client_read.c client_write.c
+
+OBJS = ${SRCS:.c=.o}
+
+NAME = bircd
+
+CFLAGS = -I. -g3 -Wall -Werror
+LDFLAGS = 
+
+CC = gcc
+RM = rm -f
+
+${NAME}:	${OBJS}
+		${CC} -o ${NAME} ${OBJS} ${LDFLAGS}
+
+all:		${NAME}
+
+clean:
+		${RM} ${OBJS} *~ #*#
+
+fclean:		clean
+		${RM} ${NAME}
+
+re:		fclean all
diff --git a/bircd/bircd b/bircd/bircd
new file mode 100755
index 0000000..db56ce6
Binary files /dev/null and b/bircd/bircd differ
diff --git a/bircd/bircd.h b/bircd/bircd.h
new file mode 100644
index 0000000..8f5c9f7
--- /dev/null
+++ b/bircd/bircd.h
@@ -0,0 +1,52 @@
+#ifndef BIRCD_H_
+# define BIRCD_H_
+
+# include <sys/select.h>
+
+# define FD_FREE	0
+# define FD_SERV	1
+# define FD_CLIENT	2
+
+# define BUF_SIZE	4096
+
+# define Xv(err,res,str)	(x_void(err,res,str,__FILE__,__LINE__))
+# define X(err,res,str)		(x_int(err,res,str,__FILE__,__LINE__))
+# define MAX(a,b)	((a > b) ? a : b)
+
+# define USAGE		"Usage: %s port\n"
+
+typedef struct	s_fd
+{
+  int	type;
+  void	(*fct_read)();
+  void	(*fct_write)();
+  char	buf_read[BUF_SIZE + 1];
+  char	buf_write[BUF_SIZE + 1];
+}		t_fd;
+
+typedef struct	s_env
+{
+  t_fd		*fds;
+  int		port;
+  int		maxfd;
+  int		max;
+  int		r;
+  fd_set	fd_read;
+  fd_set	fd_write;
+}		t_env;
+
+void	init_env(t_env *e);
+void	get_opt(t_env *e, int ac, char **av);
+void	main_loop(t_env *e);
+void	srv_create(t_env *e, int port);
+void	srv_accept(t_env *e, int s);
+void	client_read(t_env *e, int cs);
+void	client_write(t_env *e, int cs);
+void	clean_fd(t_fd *fd);
+int	x_int(int err, int res, char *str, char *file, int line);
+void	*x_void(void *err, void *res, char *str, char *file, int line);
+void	init_fd(t_env *e);
+void	do_select(t_env *e);
+void	check_fd(t_env *e);
+
+#endif /* !BIRCD_H_ */
diff --git a/bircd/check_fd.c b/bircd/check_fd.c
new file mode 100644
index 0000000..81a57dd
--- /dev/null
+++ b/bircd/check_fd.c
@@ -0,0 +1,20 @@
+
+#include "bircd.h"
+
+void	check_fd(t_env *e)
+{
+  int	i;
+
+  i = 0;
+  while ((i < e->maxfd) && (e->r > 0))
+    {
+      if (FD_ISSET(i, &e->fd_read))
+	e->fds[i].fct_read(e, i);
+      if (FD_ISSET(i, &e->fd_write))
+	e->fds[i].fct_write(e, i);
+      if (FD_ISSET(i, &e->fd_read) ||
+	  FD_ISSET(i, &e->fd_write))
+	e->r--;
+      i++;
+    }
+}
diff --git a/bircd/clean_fd.c b/bircd/clean_fd.c
new file mode 100644
index 0000000..ff555e2
--- /dev/null
+++ b/bircd/clean_fd.c
@@ -0,0 +1,10 @@
+
+#include <stdlib.h>
+#include "bircd.h"
+
+void	clean_fd(t_fd *fd)
+{
+  fd->type = FD_FREE;
+  fd->fct_read = NULL;
+  fd->fct_write = NULL;
+}
diff --git a/bircd/client_read.c b/bircd/client_read.c
new file mode 100644
index 0000000..4f39d21
--- /dev/null
+++ b/bircd/client_read.c
@@ -0,0 +1,30 @@
+
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/socket.h>
+#include "bircd.h"
+
+void	client_read(t_env *e, int cs)
+{
+  int	r;
+  int	i;
+
+  r = recv(cs, e->fds[cs].buf_read, BUF_SIZE, 0);
+  if (r <= 0)
+    {
+      close(cs);
+      clean_fd(&e->fds[cs]);
+      printf("client #%d gone away\n", cs);
+    }
+  else
+    {
+      i = 0;
+      while (i < e->maxfd)
+	{
+	  if ((e->fds[i].type == FD_CLIENT) &&
+	      (i != cs))
+	    send(i, e->fds[cs].buf_read, r, 0);
+	  i++;
+	}
+    }
+}
diff --git a/bircd/client_write.c b/bircd/client_write.c
new file mode 100644
index 0000000..bf7d8bc
--- /dev/null
+++ b/bircd/client_write.c
@@ -0,0 +1,7 @@
+
+#include <sys/socket.h>
+#include "bircd.h"
+
+void	client_write(t_env *e, int cs)
+{
+}
diff --git a/bircd/do_select.c b/bircd/do_select.c
new file mode 100644
index 0000000..d5ea1a3
--- /dev/null
+++ b/bircd/do_select.c
@@ -0,0 +1,8 @@
+
+#include <stdlib.h>
+#include "bircd.h"
+
+void	do_select(t_env *e)
+{
+  e->r = select(e->max + 1, &e->fd_read, &e->fd_write, NULL, NULL);
+}
diff --git a/bircd/get_opt.c b/bircd/get_opt.c
new file mode 100644
index 0000000..6fef11f
--- /dev/null
+++ b/bircd/get_opt.c
@@ -0,0 +1,15 @@
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "bircd.h"
+
+void	get_opt(t_env *e, int ac, char **av)
+{
+  if (ac != 2)
+    {
+      fprintf(stderr, USAGE, av[0]);
+      exit(1);
+    }
+  e->port = atoi(av[1]);
+}
+
diff --git a/bircd/init_env.c b/bircd/init_env.c
new file mode 100644
index 0000000..2ad0c93
--- /dev/null
+++ b/bircd/init_env.c
@@ -0,0 +1,20 @@
+
+#include <stdlib.h>
+#include <sys/resource.h>
+#include "bircd.h"
+
+void		init_env(t_env *e)
+{
+  int		i;
+  struct rlimit	rlp;
+
+  X(-1, getrlimit(RLIMIT_NOFILE, &rlp), "getrlimit");
+  e->maxfd = rlp.rlim_cur;
+  e->fds = (t_fd*)Xv(NULL, malloc(sizeof(*e->fds) * e->maxfd), "malloc");
+  i = 0;
+  while (i < e->maxfd)
+    {
+      clean_fd(&e->fds[i]);
+      i++;
+    }
+}
diff --git a/bircd/init_fd.c b/bircd/init_fd.c
new file mode 100644
index 0000000..4935ce2
--- /dev/null
+++ b/bircd/init_fd.c
@@ -0,0 +1,27 @@
+
+#include <string.h>
+# include <sys/select.h>
+#include "bircd.h"
+
+void	init_fd(t_env *e)
+{
+  int	i;
+
+  i = 0;
+  e->max = 0;
+  FD_ZERO(&e->fd_read);
+  FD_ZERO(&e->fd_write);
+  while (i < e->maxfd)
+    {
+      if (e->fds[i].type != FD_FREE)
+	{
+	  FD_SET(i, &e->fd_read);
+	  if (strlen(e->fds[i].buf_write) > 0)
+	    {
+	      FD_SET(i, &e->fd_write);
+	    }
+	  e->max = MAX(e->max, i);
+	}
+      i++;
+    }
+}
diff --git a/bircd/main.c b/bircd/main.c
new file mode 100644
index 0000000..55a674e
--- /dev/null
+++ b/bircd/main.c
@@ -0,0 +1,13 @@
+
+#include "bircd.h"
+
+int	main(int ac, char **av)
+{
+  t_env	e;
+
+  init_env(&e);
+  get_opt(&e, ac, av);
+  srv_create(&e, e.port);
+  main_loop(&e);
+  return (0);
+}
diff --git a/bircd/main_loop.c b/bircd/main_loop.c
new file mode 100644
index 0000000..88c2d27
--- /dev/null
+++ b/bircd/main_loop.c
@@ -0,0 +1,12 @@
+
+#include "bircd.h"
+
+void	main_loop(t_env *e)
+{
+  while (1)
+    {
+      init_fd(e);
+      do_select(e);
+      check_fd(e);
+    }
+}
diff --git a/bircd/srv_accept.c b/bircd/srv_accept.c
new file mode 100644
index 0000000..ebdd2dc
--- /dev/null
+++ b/bircd/srv_accept.c
@@ -0,0 +1,21 @@
+
+#include <stdio.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include "bircd.h"
+
+void			srv_accept(t_env *e, int s)
+{
+  int			cs;
+  struct sockaddr_in	csin;
+  socklen_t		csin_len;
+
+  csin_len = sizeof(csin);
+  cs = X(-1, accept(s, (struct sockaddr*)&csin, &csin_len), "accept");
+  printf("New client #%d from %s:%d\n", cs,
+	 inet_ntoa(csin.sin_addr), ntohs(csin.sin_port));
+  clean_fd(&e->fds[cs]);
+  e->fds[cs].type = FD_CLIENT;
+  e->fds[cs].fct_read = client_read;
+  e->fds[cs].fct_write = client_write;
+}
diff --git a/bircd/srv_create.c b/bircd/srv_create.c
new file mode 100644
index 0000000..97b2d96
--- /dev/null
+++ b/bircd/srv_create.c
@@ -0,0 +1,22 @@
+
+#include <stdlib.h>
+#include <netdb.h>
+#include <netinet/in.h>
+#include "bircd.h"
+
+void			srv_create(t_env *e, int port)
+{
+  int			s;
+  struct sockaddr_in	sin;
+  struct protoent	*pe;
+  
+  pe = (struct protoent*)Xv(NULL, getprotobyname("tcp"), "getprotobyname");
+  s = X(-1, socket(PF_INET, SOCK_STREAM, pe->p_proto), "socket");
+  sin.sin_family = AF_INET;
+  sin.sin_addr.s_addr = INADDR_ANY;
+  sin.sin_port = htons(port);
+  X(-1, bind(s, (struct sockaddr*)&sin, sizeof(sin)), "bind");
+  X(-1, listen(s, 42), "listen");
+  e->fds[s].type = FD_SERV;
+  e->fds[s].fct_read = srv_accept;
+}
diff --git a/bircd/x.c b/bircd/x.c
new file mode 100644
index 0000000..63ea876
--- /dev/null
+++ b/bircd/x.c
@@ -0,0 +1,28 @@
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "bircd.h"
+
+int	x_int(int err, int res, char *str, char *file, int line)
+{
+  if (res == err)
+    {
+      fprintf(stderr, "%s error (%s, %d): %s\n", 
+	      str, file, line, strerror(errno));
+      exit (1);
+    } 
+  return (res);
+}
+
+void	*x_void(void *err, void *res, char *str, char *file, int line)
+{
+  if (res == err)
+    {
+      fprintf(stderr, "%s error (%s, %d): %s\n", 
+	      str, file, line, strerror(errno));
+      exit (1);
+    } 
+  return (res);
+}
diff --git a/main_gepeto.cpp b/main_gepeto.cpp
new file mode 100644
index 0000000..754e9be
--- /dev/null
+++ b/main_gepeto.cpp
@@ -0,0 +1,95 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <arpa/inet.h>
+
+#define PORT 6667
+#define BUF 512
+
+typedef struct {
+    int fd;
+    char nick[64];
+    char user[64];
+    int has_nick;
+    int has_user;
+} Client;
+
+void send_line(int fd, const char *msg) {
+    send(fd, msg, strlen(msg), 0);
+}
+
+void welcome(Client *c) {
+    char msg[BUF];
+    snprintf(msg, sizeof(msg),
+             ":mini-irc 001 %s :Welcome to Mini IRC Server, %s!\r\n",
+             c->nick[0] ? c->nick : "guest",
+             c->nick[0] ? c->nick : "guest");
+    send_line(c->fd, msg);
+}
+
+int main() {
+    int sfd = socket(AF_INET, SOCK_STREAM, 0);
+    struct sockaddr_in addr = { .sin_family = AF_INET,
+                                .sin_addr.s_addr = INADDR_ANY,
+                                .sin_port = htons(PORT) };
+    int opt = 1;
+    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
+    bind(sfd, (struct sockaddr *)&addr, sizeof(addr));
+    listen(sfd, 5);
+    printf("Servidor IRC escuchando en %d\n", PORT);
+
+    for (;;) {
+        struct sockaddr_in cli;
+        socklen_t l = sizeof(cli);
+        int cfd = accept(sfd, (struct sockaddr *)&cli, &l);
+        if (cfd < 0) continue;
+
+        printf("Conexi칩n desde %s:%d\n", inet_ntoa(cli.sin_addr),
+               ntohs(cli.sin_port));
+
+        Client c = { .fd = cfd, .has_nick = 0, .has_user = 0 };
+        send_line(c.fd, ":mini-irc NOTICE AUTH :Bienvenido al Mini IRC!\r\n");
+
+        char buf[BUF];
+        while (1) {
+            ssize_t n = recv(c.fd, buf, BUF - 1, 0);
+            if (n <= 0) break;
+            buf[n] = '\0';
+            printf(">> %s", buf);
+
+            if (!strncmp(buf, "PING", 4)) {
+                char pong[BUF];
+                snprintf(pong, sizeof(pong), "PONG %s\r\n", buf + 5);
+                send_line(c.fd, pong);
+            }
+            else if (!strncmp(buf, "NICK", 4)) {
+                sscanf(buf + 5, "%63s", c.nick);
+                c.has_nick = 1;
+                if (c.has_user && c.has_nick)
+                    welcome(&c);
+            }
+            else if (!strncmp(buf, "USER", 4)) {
+                sscanf(buf + 5, "%63s", c.user);
+                c.has_user = 1;
+                if (c.has_user && c.has_nick)
+                    welcome(&c);
+            }
+            else if (!strncmp(buf, "JOIN", 4)) {
+                char chan[64];
+                sscanf(buf + 5, "%63s", chan);
+                char msg[BUF];
+                snprintf(msg, sizeof(msg),
+                         ":%s!%s@mini JOIN :%s\r\n", c.nick, c.user, chan);
+                send_line(c.fd, msg);
+            }
+            else if (!strncmp(buf, "QUIT", 4)) {
+                send_line(c.fd, "ERROR :Bye!\r\n");
+                break;
+            }
+        }
+
+        close(c.fd);
+        printf("Cliente desconectado\n");
+    }
+}
diff --git a/manuel b/manuel
new file mode 100755
index 0000000..e67ea0c
Binary files /dev/null and b/manuel differ
diff --git a/test b/test
new file mode 160000
index 0000000..b9f17b5
--- /dev/null
+++ b/test
@@ -0,0 +1 @@
+Subproject commit b9f17b53d9e9b8385ad9e33dbfb9ab60347dff8f
